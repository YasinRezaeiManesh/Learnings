learning PostgreSQL day 1
History


day 2
terminology

Cluster ==>  تک سروری که در حال اجراس
Catalog ==> دیتابیسی که شامل اطلاعات دیتابیس های دیگس
Schema ==> برای سازماندهی دیتابیس استفاده میشه ( مثل یه پوشس که دسته بندی میکنه)
PG-DATA ==> یک متغیره که اشاره میکنه به ادرسی که دیتا در ان ذخیره شده
Postmaster ==> اولین پروسسی که با اجرای دیتابیس انجام میشه و مسئولیت هندل کانکشن های دیگه رو داره


day 3
virtual machine with vagrant

1 ==> Download and install vmware and vagrant
2 ==> create dir djtest
3 ==> create first vagrant file


day 4
install PostgreSQL

1 ==> download and install PostgreSQL
2 ==> create user and set password
3 ==> first query and create first table {
    CREATE TABLE example(
        id SERIAL PRIMARY KEY,
        example TEXT,
        example2 INTEGER
    );
}
4 ==> first insert to table {
    INSERT INTO example(example, example2)
    VALUES
    ('test', 123),
    ('test2', 456);
}
5 ==> select information {
    SELECT * FROM example;
}


day 5
learning...

1 ==> filtering {
    SELECT * FROM example
    WHERE name=test;
}

2 ==> Order By {
    SELECT * FROM example
    ORDER BY test ASC; -> صعودی
}
{
    SELECT * FROM example
    ORDER BY test DESC; -> نزولی
}

3 ==> Update field {
    SELECT * FROM users
    SET test = 'newtest'
    WHERE name = example -> اگه مشخص نکنی کدوم فیلد همه رو عوض میکنه
}

4 ==> Deleting {
    DELETE FROM example
    WHERE name = 'test'
}


day 6
learning...
1 ==> Relationships (Foreign Key) {
    CREATE TABLE users(
        id SERIAL PRIMARY KEY,
        name text,
    );
    CREATE TABLE orders(
        id SERIAL PRIMARY KEY,
        user_id INTEGER,
        product_name TEXT,
        amount NUMERIC,
        FOREIGN KEY (user_id) REFERENCES users(id)
    );
}

2 ==> Show orderings {
    SELECT orders.id, users.name, orders.product_name, orders.amount
    FROM orders
    JOIN users ON orders.user_id = users.id;  --> این خط میگ ک جدول کاربر ها رو به جدول سفارش ها وصل کن به شرطی ایدی کاربر در جدول سفارش برابر باشه با ایدی کاربر در جدول کاربران
}

3 ==> Drop Table {
    DROP TABLE IF EXISTS example; --> این میگ اگ جدول وجود داشت پاکش کن اگه نداشت ارور نده
}

4 ==> Left Join {
    SELECT orders.id, orders.product_name, users.name, orders.amount
    FROM orders
    LEFT JOIN users ON orders.user_id = users.id; --> null این همون جوین بالا هستش ولی فرقش اینه توی کوئری کاربرهایی که از جدول کاربران حذف شدن ولی سفارششون هست رو نشون میده ولی به جای اسمشون میزاره
}

day 7
learning ...

1 ==> Right Join {
    SELECT orders.id, orders.product_name, users.name, orders.amount
    FROM orders
    RIGHT JOIN users on orders.user_id; --> null این برعکس بالاییه یعنی مثلا کاربرهایی که سفارشی ندارن رو نشون میده ولی به جای سفارش میزاره
}

2 ==> Full Join {
    SELECT orders.id, orders.product_name, users.name, orders.amount
    FROM orders
    FULL JOIN users ON orders.user_id; --> این همه رو نشون میده ینی مثلا کاربر بود سفارش نداشت به جا سفارش نال میزاره یا کاربر نبود سفارش بود به جا کاربر نال میزاره
}

3 ==> Group BY {
    SELECT users.name, SUM (orders.amount) --> sum, avg, count... این دستورات بلدی همون
    FROM users
    JOIN orders ON users.id = orders.user_id
    GROUP BY users.name; --> این دستور میاد بر اساس چیزی که بش میگی دسته بندی میکنه ، مثلا اینجا میاد سفارش هایی که اسماشون مشترکه جدا میکنه و مجموع سفارششون رو حساب میکنه
}

4 ==> Funcs {
    SUM --> جمع
    AVG --> میانگین
    count --> تعداد
}

5 ==> filtering {
    SELECT users.name, SUM(orders.amount) AS total_amount
    FROM users
    JOIN orders ON users.id = orders.user_id
    GROUP BY users.name
    HAVING SUM(orders.amount) > 5000000; --> این دستور مثل همون وِر هستش منتها این مال بعد از گروپ بای هست اون برای قبل گروپ بای
    به این دلیل از اسم متغیر در دستور هوینگ استفاده نکردیم چون شرط قبل از نام گذاری اجرا میشه در کوئری
}

6 ==> Prioritizing Commands {
    1. FROM
    2. JOIN
    3. WHERE
    4. GROUP BY
    5. HAVING
    6. SELECT
    7. ORDER BY
    8. LIMIT
}
